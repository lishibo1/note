一.JS中几种循环的用法和比较
	
	a. for-in 循环 : 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）for-in循环主要用来循环对象，取到的值是下标key，获取当前属性的值需要用obj[key]来获取。

	//声明一个Peson类
function Person(){
    this.name = "张三";
    this.age = 14;
    this.func1 = function(){
        
    }
}
//实例化这个类
var zhangsan = new Person();
//使用for-in遍历这个对象
for(keys in zhangsan){
    console.log(zhangsan[keys])
}

输出 ：张三    14    f()


	b . for-of  :  for-of是ES新增的循环， for-of 可以循环字符串、数组以及类数组对象(比如选中的dom对象、函数参数的arguments对象)，但是不能循环正常对象。

	      // 字符串
        var str = "hello";
        
        for (let s of str) {
          console.log(s); // h e l l o
        }
        
        // DOM NodeList对象
        let paras = document.querySelectorAll("p");
        
        for (let p of paras) {
          p.classList.add("test");
        }
        
        // arguments对象
        function printArgs() {
          for (let x of arguments) {
            console.log(x);
          }
        }
        printArgs('a', 'b');// 'a' 'b'

	
	c. forEach :  forEach是用来循环数组的，forEach的回调中有三个参数，分别为数组当前值value 、 数组下标 index 、当前数组。其中第一个参数是必须的，其余两个参数可有可无。(forEach只能循环数组，不能循环类数组对象，比如dom对象不能被循环document.querySelectorAll("p");)
	
	let arr = [1,2,3];
arr.forEach(function(value,index，arr){
 console.log(value,index，arr)
})
// 1 0 [1,2,3]
// 2 1 [1,2,3]
// 3 2 [1,2,3]

	d . map : map主要是用来循环数组，不能用来循环普通对象，原生的类数组对象也不能循环（document.querySelectorAll(“p”)），但是可以循环jquery对象（$(“.name”)）。

	map的用法：当map循环的是数组时，跟forEach用法一样。
	arr.map((value,index,arr)=>{
		console.log(value, index,arr)
	})
	当map循环的是jquery对象时，用法如下(只有两个参数，$(item)可以获取到当前jquery对象)
	$(“li”).map((index,item)=>{
		console.log(index,$(item));
	})

二、HTML、CSS、JS在页面中的加载顺序。

	CSS和JS都是嵌套在HTML页面中的,而HTML页面是按照顺序加载的，页面会从head开始解析，并下载相应的资源，在加载过程中，资源下载是异步的。当碰到script标签时，浏览器将控制权交给JavaScript引擎，此时页面停止渲染。解析完后浏览器将控制权又交给浏览器渲染引擎。（这个只是针对原生的页面，在框架中并不实用。）

三、基本类型与引用类型。

	1.JavaScript中的变量类型有哪些？

	（1）值类型（基本类型）：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol http://es6.ruanyifeng.com/#docs/symbol )

	（2）引用类型：对象（Object）、数组（Array）、函数（Function）

 

	2.值类型和引用类型的区别

	（1）值类型：1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）

          2、保存与复制的是值本身

          3、使用typeof检测数据的类型

          4、基本类型数据是值类型

	（2）引用类型：1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）

           2、保存与复制的是指向对象的一个指针

           3、使用instanceof检测数据类型

           4、使用new()方法构造出的对象是引用型

	重点（基本类型的基础变量被储存在栈中，值也储存在栈中，当进行比较时，比较的是值。引用类型的引用变量也储存在栈中，但是值是一个地址，指向堆内存中的对象）。

四、call和apply的用法。

	call和apply方法都是改变this的指向问题。只是传递的参数不同，如下。
	function add(c,d){
        	return this.a + this.b + c + d;
    	}

    	var s = {a:1, b:2};
    	console.log(add.call(s,3,4)); // 1+2+3+4 = 10
    	console.log(add.apply(s,[5,6])); // 1+2+5+6 = 14 

	当传递的参数是对象s时，此时运行add()函数，this就是指向s对象的。

五、window中常用的处理函数split、splice、slice。

	split是用来处理字符串的，split中参数是打散字符串的规则，如下意思为碰到str中有逗号时就拆开，显然返回的数组只有一项。
	var str = “sdf”； str.split(',') 
	splice是用来处理数组的。splice会改变原来的数组，返回的值为被删除的部分项。
	var arr = [11,22,33,44,55];  var arr1 = arr.splice(1,2,12);
	slice既可以处理字符串，又可以处理数组。
	var str = 'sadfasf';   str.slice(1,3);
	join是用来处理数组，按照指定规则把数组变为字符串，如果传递的参数为空时，将返回不带逗号的字符串。
	var arr = [1111,2222,3333,4444]; arr.join("");

	(重点：上面的方法中，只有splice会改变调用对象，其余方法都不会改变原来的值。)

六、window中对象的使用。
	
	window中的常用对象有location setInterval setTimeout innerHeight localStorage等

	1、location是一个获取地址栏地址的对象
		window.location.href:获取地址栏中的完整地址。
		window.location.protocol:获取URL的协议
		window.location.host:获取当前URL的主机名（域名）和端口号
		window.location.port:获取当前URL的端口号
		window.location.hostname:获取当前URL的主机名（域名）
		window.location.pathname:获取URL中的文件路径，就是当前页面的路径。
		window.location.search:获取URL中的参数
	2、cookie  session  localStorage  sessionStorage等的用法和比较。(localStorage和sessionStorage保存数据都是保存在本地浏览器中，而且保存的数据是保存在当前浏览器域名下。)
		cookie是服务器发送给客服端的特殊信息，存储在客服端，比如用户登陆时，后端会保存用户登陆信息，返回信息存储在cookie中。 cookie可以设置保留时间，如果没有设置保留时间，则关闭浏览器就会失效。每次发送请求都会带上cookie信息。cookie的存储容量小，且每次发送请求时都会携带发送cookie，因此H5新特性中的Web Storage很好的解决了这个问题。
		localStorage是将需要保存的信息存储在本地的硬件设备上，且属于永久存储，关闭浏览器数据不会被清除，只有主动删除才会失效。存储的大小为5MB左右。localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（项目中用到过，新生开卡功能，流程比较复杂，有几个页面需要填写信息，为了方便用户，如果用户填写了几个页面信息，但没填写完，突然有事电脑关了，下次进入开卡时，会提示你是否继续申请开卡。这个功能就是用localStorage实现的。在第一次提交主页信息时，利用localStorage保存了一个后台返回的token码，跟电话号码一一对应。当下次进入开卡主页时，用localStorage.getItem("token"),如果存在token码，就会走另外一套逻辑，用token码call后台接口，返回上次提交的数据，然后渲染在页面上。)
		sessionStorage存储的数据只在当前浏览器窗口有效，关闭浏览器窗口会被销毁，存储大小为5MB。sessionStorage：敏感账号一次性登录；

七、promise的用法。

	 promise是解决异步回调问题的，如下。promise是个构造函数，接受一个函数作为参数，该函数有两个参数，分别为成功回调和失败回调。当执行完Promise（）中的函数时，会继续执行js中的代码，以下执行输出为。(注意promise里面的代码是同步的)

	a  c  b  1

	 new Promise((resolve, reject) => {
      		console.log('a');
      		setTimeout(() => {
        		resolve(1);
      		}, 10);
    	 }).then((data) => {
      		console.log('b');
      		console.log(data);
         )
	 console.log('c');

八、对OOP的理解。（面向对象的好处：代码整洁井然有序，便于后期维护）

	我上一段工作经历就是面向对象编程的。面向对象编程与面向过程编程之间的差别，面向过程编程是流程化的，一步一步分析问题，一步一步实现问题，而面向对象编程是抽象化的，抽象一个类，里面有解决问题的方法和数据，需要实现什么功能直接调用就可以了。面向对象有三大特性。第一个特性封装：隐藏对象的属性和实现细节，对外提供访问方式，提高代码的复用率和可维护性，并且能提高团队开发效率。像我提供的上传的方法，只提供一个接口，说明使用方法，不需要别人知道怎么实现的。第二个特新继承：继承是指可以让某个类型的对象获得另一个类型的对象的属性和方法，比较常用的方法是使用call()方法或原型链的方式实现继承。原型链方式继承比较复杂，简单点说可以把你想要继承的构造函数的原型合并到自身的原型中。我上个项目就是使用原型链继承方式，在当前页面执行一系列的框架初始化方法。(合并两个对象的方法Object.assign({},obj1,obj2)和$.extend一样)我们这个项目是在当前页面js中使用call()方法来继承框架的类里面的方法，然后用$.extend来继承框架类中原型上的方法和属性。多态就是不同对象调用同一方法可以产生不同的效果,比如子对象重写一个跟父对象相同的方法，这个很少用到，跟多态容易搞混的重载在项目中到是用的多，根据所传参数个数不同执行不同的操作。
1.谈谈你对OOP的理解？
OOP是面向对象编程，特征分别是封装、继承、多态、抽象。
封装：封装是指将对象信息状态通过访问权限修饰符隐藏在对象内部，不允许外部程序直接访问，如果外部程序要访问对象内部，可以调用内部提供的get或set方法。简单来说，封装就是要找出某一类事务的公性然后提取出来。
继承：子类继承了父类所有的成员方法和属性，并且可以拥有自己特性。继承解决了代码的重用问题
多态：多态存在的三个条件1.继承2.重写3.父类引用指向子类对象
多态的实现方式1.接口实现，继承父类方法重写，同一个类中进行重载
重载：多个同名函数同时存在，具有不同的参数个数/类型，返回值类型可以相同可
以不同，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性，存在于父类和子类、同类中
重写：1.参数列表必须完全与被重写的方法相同
2.返回的类型必须一直与被重写的方法的返回类型相同
3.访问修饰符的限制一定要大于被重写方法的访问修饰符
4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
5.存在于父类和子类之间，方法被定义为final不能被重写。
抽象：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。
抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。


九、介绍一下必包。
	闭包就是能读取其它函数内部变量的函数。闭包的原理就是作用域问题，当你访问某个变量时，会先在当前作用域下查找，如果当前作用域不存在就会在外层作用域中寻找，直到找到window作用域，而外层作用域访问不到内层作用域中的变量。我们知道，一般的方法执行之后内部变量都会被释放，但是当你在这个方法中返回一个内部函数，这个内部函数就可以访问外部函数的所有变量，因此执行外部函数之后，函数内的内部变量不就被释放。可以在函数外不获取到函数内的变量。
	闭包就是能够读取其他函数内部变量的函数
	一般来说，函数作用域中的变量在函数外部是无法访问的，闭包可以理解为读取其它函数作用域中变量的函数，闭包可以将函数内部和函数外部连接起来。闭包的优点，可以读取函数内部的变量。

十、原型和原型链。(Function函数是由Function函数生成的，所以Function函数对象的__proto__指向Function.prototype。JavaScript规定Object.prototype为原型链的顶端，Object.prototype.__proto__ =  null。JavaScript规定，Function.prototype.__proto__指向Object的原型。)
	
	每个函数都自带一个prototype属性，prototype属性指向一个对象，就是原型对象。每个对象自带一个__proto__属性，一般情况来说，这个__proto__属性指向生成当前实例的类的原型。当我们访问对象的一个属性时，它会先在自身中寻找，如果有则直接使用，如果没有就到__proto__所指的原型中找，如果原型中有则直接使用，如果没有就到原型的原型中寻找，直到找到Object对象的原型为止，Object的原型就是原型链的顶端。如创建一个构造函数Person，let一个变量people等于new Person，那么实例people中就有一个__proto__属性指向生成这个对象的类的原型，也就是构造函数的原型（在构造函数内部可以定义一些属性，这些属性会在实例化时保存在每个实例内部，比如Person中定义age和name等，可以在new时传入参数来实现各个实例产生不同的属性值，构造函数prototype属性指向的原型对象里面可以定义一些方法，这些方法是所有实例公用的，也就是实例__proto__所指向的对象。），普通函数的原型都是系统自动生成的‘object’类型的对象，竟然是对象，它里面同样有一个属性__proto__指向Object函数的原型，而Object函数的原型中__proto__属性是null，也就是原型链的顶端。	

十一、sort排序函数的原理和使用方法。

	sort函数是对数组进行排序，依次取数组中的两个元素进行比较，就像冒泡排序样，sort函数接受一个回调函数作为参数，如果回调函数返回的值大于0，则a排到b的后面（大于0则a，b调换位置），如果回调函数的值等于0，则不换位置，如果回调函数的值小于0，则b排到a的后面（小于0则a，b位置不变）。

	arr=[10,5,8,20,1000,2];
	arr.sort((a,b)=>{return a-b;}) 升序
	arr.sort((a,b)=>{return b-a;}) 降序
	（总结一句话，就是当回调函数的值大于0时，a、b交换位置）

十二、冒泡排序。

function setSort(arr) {
    let i = arr.length, j = 0;
    while (i > 1) {
      for (j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          const tem = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = tem;
        }
      }
      i--;
    }
 }
var arr=[10,6,20,5,1000,1];
setSort(arr);

冒泡的优化，当序列正确时，排序任然会进行下一轮，因此可以设置一个flag判断，当序列正确时，不在排序，如下。
function setSort(arr) {
    let i = arr.length, j = 0,flag;
    while (i > 1) {
	flag = false;
      for (j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          const tem = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = tem;
	  flag = true;
        }
      }
      i--;
      if(!flag) break;
    }
 }
var arr=[10,6,20,5,1000,1];
setSort(arr);

冒泡还可以进一步优化，当后面一部分序列已经正确时，就没必要进一步比较后面那些序列了，可以记录有序数列的下标，下次比较只需要比较到此位置为止。

function setSort(arr) {
    let i = arr.length, j = 0,flag;
    Let lastIndex = i-1;
    while (i > 1) {
	flag = false;
      for (j = 0; j < lastIndex; j++) {
        if (arr[j] > arr[j + 1]) {
          const tem = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = tem;
	  flag = true;
	  lastIndex = j;
        }
      }
      i--;
      if(!flag) break;
    }
 }
var arr=[10,6,20,5,1000,1];
setSort(arr);

十三、选择排序
选择排序是取出下标为i的元素和后面的所有元素进行比较，如果第i个元素大于后面的元素就对换位置，这样经过第一轮排序，最小的元素就到最前面了
function chooseSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
      for (let j = i + 1; j < arr.length; j++) {
        if (arr[i] > arr[j]) {
          const tem = arr[i];
          arr[i] = arr[j];
          arr[j] = tem;
        }
      }
    }
  }
十四、快速排序
quickSort(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const centerIndex = Math.floor(arr.length / 2);
    const left = [];
    const right = [];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] >= arr[centerIndex] && i !== centerIndex) {
        right.push(arr[i]);
      }
      if (arr[i] < arr[centerIndex] && i !== centerIndex) {
        left.push(arr[i]);
      }
    }
    return quickSort(left).concat(arr[centerIndex]).concat(quickSort(right));
  }

十五、事件的冒泡
	事件流分为三个阶段，事件捕获、事件目标阶段、事件冒泡阶段。当在浏览器中触发某个事件时，如click事件，点击了一个div，顶级对象document就会发出一个事件流，向被点击的目标元素流去，捕捉所有绑定有点击事件的元素，到达点击元素后，就会向上冒泡，执行所有捕获的click事件函数。
十六、事件代理
	事件代理实现的原理就是事件的冒泡行为。用同一个dom元素注册多个同类型事件。如要给一个列表的li绑定点击事件，可以在父元素ul上绑定一个点击事件，当你点击li时，事件会冒泡到ul上执行click的方法
十七、什么是模块化开发，有什么优点？

	模块化开发就是将一个大型项目拆分为不同的功能模块，由不同的模块功能拼凑成大型系统。
十八、后端session和cookie。

	当每个用户第一次访问登陆接口时（第一次指在新打开的浏览器中访问，如果访问后关闭当前窗口新开一个窗口继续访问，session还保存在，后端设置session保存时间一般是三十分钟，关掉浏览器当前域下的cookie才会被删除），后端会生成一个session ID来记录当前用户的状态并开辟一个内存空间来处理当前用户的数据，并在请求返回中将session id写入浏览器cookie，当浏览器访问这个域下面的任何service时，都会携带cookie信息发送给后端，后端根据这个session id来在指定内存中处理当前用户数据。
	cookie分为会话cookie和持久cookie，会话cookie在会话结束时就会消失，会话结束指关闭浏览器，会话cookie保存在浏览器的内存中，且关闭当前tab cookie不会消失，在IE中cookie不能跨进程，chrom中可以跨进程。
	持久cookie保存在硬盘上，关闭浏览器再次打开，只要cookie没有过期，cookie信息还保存在，持久cookie可以跨进程。
十九、xss攻击。

	xss攻击通常指黑客通过 HTML 注入 篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击行为。比如有一个留言功能，所有用户在输入框输入内容点击提交留言就会显示在下方，如果你在输入框里面输入script标签并将src属性指向你自己的服务器，提交到服务器端，服务器返回用户写入到内容并append到页面上，就会执行这个script标签，由于jsonp可以实现跨域，所以可以在本网站获取数据写入自己服务器内。
	我上个项目就有解决xss攻击问题，所有从前端发送给后端的数据，都会经过转义处理，后端接收后进行反转义处理将正常的数据存入数据库，所有后端送给前端处理的数据也都会经过转义处理，前端渲染需要进行反转义处理。因为项目开发到中后期才注意到xss攻击，所以需要找到改动尽量小的设计方案，因此就想到在原先的方法上进行封装，将.val()方法在框架中改写igtbval()，判断.igtbval()是否穿参，没穿参说明是从页面获取内容，此时在内部使用this.val()获取到当前内容，然后调用escape进行转义，返回转义后到值。穿参是给dom元素赋值，就在igtbval()方法中进行反转义，返回this对象，让igtbval()也可以实现链式操作。

二十、阻止冒泡和默认行为的方法

	阻止默认行为： event.preventDefault();
	阻止冒泡：event.stopPropagation();
	
二十一、jsonp的原理和使用。

	由于浏览器同源策略的限制，非同源下的请求将会产生跨域问题，同源指协议、域名、端口都相同。但我们发现html中的img图片的src属性指向其它服务器时可以获取到图片，获取的方式是get请求，因此我们可以利用这种方式实现跨域，也就是jsonp。实现的方式是在js中动态生成一个script标签，将src属性指向需要获取数据的地址，并在地址后面传递一个回调函数给后端，后端接受到这个参数后，将需要返回的数据放入函数参数中，前端运行这个回调函数就能拿到后端的数据。

二十二、promise.all用法和async await。

	function setPromise(num){
		return new Promise((resolve,reject)=>{
			setTimeout(()=>{resolve(num)},1000);
		});
	}
	Promise.all([setPromise(1111),setPromise(2222)]).then((x)=>{console.log(x)},(y)=>{})
	Promise.all()传入一个数组，数组中传入多个返回Promise对象的函数，then()中第一个参数是成功执行的方法，x是返回的一个数组，对应传入是的函数返回值，第二个参数是失败执行的方法。（Promise.all()会等所有Promise都执行完后在调用）。

	async await是配合使用的，async定义一个函数，用await接收一个Promise对象，并且await后面的代码会等Promise返回resolve之后在执行。但是async函数外的代码还是正常执行。

	function setPromise(num){
		return new Promise((resolve,reject)=>{
			setTimeout(()=>{reject(num)},1000);
		});
	}
	async function test(){
		try{
			console.log('aaaaa');
			var n = await setPromise(1111);
			console.log(n);
		} catch(error) {
			console.log("失败了"+error);
		}
	}
	test();
	console.log(3333);
	输出结果为 
	aaaaa
	3333
	失败了1111

二十三、js中判断数据的类型。

	使用Object.prototype.toString.call(data)可以判断出所有类型，得出的值是一个数组。
	console.log(Object.prototype.toString.call(123));    //[object Number]
	console.log(Object.prototype.toString.call('123'));    //[object String]
	console.log(Object.prototype.toString.call(undefined));    //[object Undefined]
	console.log(Object.prototype.toString.call(true));    //[object Boolean]
	console.log(Object.prototype.toString.call({}));    //[object Object]
	console.log(Object.prototype.toString.call([]));    //[object Array]
	console.log(Object.prototype.toString.call(function(){}));    //[object Function]
	console.log(Object.prototype.toString.call(null));    //[[object Null]]

	使用typeof可以判断出基本类型，但是不能判断null、Array、Object。
	console.log(typeof bool); //boolean
	console.log(typeof num);//number
	console.log(typeof str);//string
	console.log(typeof und);//undefined
	console.log(typeof nul);//object
	console.log(typeof arr);//object
	console.log(typeof obj);//object
	console.log(typeof fun);//function
	console.log(typeof s1); //symbol

	使用instanceof可以判断出数组，对象跟函数，其它类型无法判断。
	console.log(bool instanceof Boolean);// false
	console.log(num instanceof Number);// false
	console.log(str instanceof String);// false
	console.log(und instanceof Object);// false
	console.log(nul instanceof Object);// false
	console.log(arr instanceof Array);// true
	console.log(obj instanceof Object);// true
	console.log(fun instanceof Function);// true
	console.log(s1 instanceof Symbol);// false

	因此typeof和instanceof配合可以判断出所有类型。
	注意大小写， 只有typeof是小写。

二十四、HTTP的了解。

	

二十五、文件上传和图片上传。
	
	前后端上传是以文件流进行传输的，文件流包括文件的基本信息和文件内容。后端用MultipartFile类去接收和解析
	使用form文件上传时要将enctype设置为multipart/form-data类型，这个编码会对文件内容进行处理。
	如果使用ajax上传文件，则需要使用浏览器提供的FormData构造函数，实例化一个对象，将文件内容append到对象中，发送给后端。
	当上传图片时预览：
	var reader=new FileReader();  //调用FileReader
        reader.readAsDataURL(file); //将文件读取为 DataURL(base64)
        reader.onload=function(evt){   //读取操作完成时触发。
               $("#img").attr('src',evt.target.result)  //将img标签的src绑定为DataURL
		$.ajax({
            		url: 'upload_base64.php',
            		type: 'POST',
            		data: { data: evt.target.result },
            		dataType: 'json',
            		success: function (res) {
                
            		},
            		error: function (res) {
               			 alert('上传出错');
            		}
        	});
        };
	

二十六、什么是服务器端渲染和浏览器端渲染，服务器端渲染是怎么把数据放在页面上的。
	
	浏览器渲染指的是当用户在浏览器中输入地址时，服务器端给浏览器端返回一个HTMl页面，浏览器渲染这个HTML页面，并下载当前页面需要的资源，在下载资源时是异步的，当碰到script标签时，浏览器停止渲染页面，会执行相应的js代码，js会请求页面所需数据，并将数据显示在页面上，浏览器接着渲染页面，直到整个过程完成。
	服务器端渲染指的是当用户在浏览器中输入地址时，服务器端会在服务端执行相应操作，通过模版语法，在服务端将页面所需数据全部放入页面对应位置，返回一个完整的HTML页面给浏览器，浏览器渲染返回的HTML页面只需下载对应资源，而不需要在向服务器发送请求数据。

二十七、arguments的理解。

	arguments是函数内的Arguments的实例对象。
	1.arguments对象和Function是分不开的。
	2.因为arguments这个对象不能显式创建。
	3.arguments对象只有函数开始时才可用。
	arguments有个属性callee，该属性指向自身函数，arguments是一个对象，对象内部包含函数的实参，所以函数内部this指向arguments对象，如下输出 10，2.
	var length = 10;
	function fn() {
  		console.log(this.length);
	}
	var obj = { 
  		method: function(fn) {
    			fn();
    			arguments[0]();
  		}
	};
	obj.method(fn, 1);

二十八、es6中var let const的区别。

	es5中只有全局作用域和函数作用域，没有块级作用域，在{}中用var定义的变量能在{}外访问，es6中有块级作用域，使用let和const在块级作用域内定义的变量只能在块级内访问，外部访问不到。const定义的变量必须赋初始值，且值不能被改变，如果const定义的变量是个引用类型的值，属性可以改变。
	var、let、const都会申明提前，但是let和var有区别，当var在后面定义变量，前面使用变量时会报undefind,当let在后面定义变量，前面使用变量时会报错，都不是报错未定义。

二十九、箭头函数和普通函数。

	箭头函数this指向函数外的this，箭头函数不能使用new，箭头函数没有prototype属性，箭头函数没有arguments对象，使用...调用arguments。

三十、es6中的Proxy。

	es6中新增的用来干预默认行为的，如定义一个obj，当给obj赋值时会调用set方法，当获取obj某属性值时，会调用get方法。
var person = { age: 1 };

person = new Proxy( person, {
　　set: function( target, prop, value ){
　　　　if (prop === 'age') {
　　　　　　if( typeof value !== 'number' ) throw new Error('age value type error');
　　　　　　target[prop] = value < 0 ? 0 : ( value > 100 ? 100 : value );
　　　　} else {
　　　　　　return Reflect.set(...arguments);
　　　　}
　　}
});

三十一、es6新增哪些内容

	es6中有块级作用域，let和const定义变量，箭头函数、模版字符串、解构、对象字面量赋值简写、promise、代理proxies等。
	// new Object() 方式创建(es5创建对象)
	var a = {  rep : 'apple' }
	var b = new Object(a)
	console.log(b) // {rep: "apple"}
	console.log(b.__proto__) // {}
	console.log(b.rep) // {rep: "apple"}

	// Object.create() 方式创建(es6创建对象)
	var a = { rep: 'apple' }
	var b = Object.create(a)
	console.log(b)  // {}
	console.log(b.__proto__) // {rep: "apple"}
	console.log(b.rep) // {rep: "apple"}

三十二、原生js怎么绑定点击事件和解除绑定。

	原生js绑定事件有两种方法，onclick和addEventListener，两者比较的差别：
	onclick给同一个元素绑定事件只能绑定一个函数，如：dd.onclick = fun1; dd.onclick = fun2;则只有fun2生效。onclik只支持事件冒泡阶段，不支持事件捕获阶段。
	addEventListener可以给同一个元素绑定多个事件，会依次执行，支持事件捕获阶段。addEventListener第三个参数默认是false，就是默认使用事件冒泡阶段触发绑定事件，当传入true时，使用的是事件捕获阶段触发事件。

	解除绑定：
	dd.oclick = null;
	addEventListener解除绑定时需要绑定函数为具名函数，如下：
	var fun = function(event){
		console.log(event.target)
		dd.removeEventListener("click",fun);
	};
	dd.addEventListener("click",fun)
	
	jquery中使用click也只能绑定一个事件函数，使用on可以绑定多个事件函数，jquery解除绑定的方法：
	$("#id").unbind("click")即解除当前选中元素的所有的点击事件,可以对click和on的方法都解除。

三十三、懒加载。

	懒加载用在当页面元素丰富，图片比较多，页面比较高时，为了防止资源加载造成页面卡顿，可以先把图片地址放在自定义属性中储存，当页面滚动到显示当前图片的位置时，将图片地址改为正确地址。

	节流函数：当事件频繁触发时，为了减轻服务器压力，可以设置固定时间在发送请求。
	function throttle(lazyTime, Fuc){
                var lastTime = null //记录上次时间
                return function(){
                    var currentTime = new Date().getTime();
                    if(!lastTime){ //初始化时间
                        lastTime = currentTime;
                    }
                    if(lastTime + lazyTime < currentTime){
                        Fuc();
                        lastTime = currentTime;
                    }
                }
            }
            window.onscroll = throttle(50, lazyload) //事件回调是个闭包

	防抖函数：当持续触发某个事件时，为了减轻服务器压力，当一定时间内不在触发事件时会调用函数。

	   function debounce(Fuc, time){ //防抖
                let timer = null
                return function () {
                    clearTimeout(timer); 
		    //清除定时器，如果触发时间超过设定时间，则定时器中的代码不能执行
                    timer = setTimeout(() => {
                        Fuc()
                    }, time); //重新赋值定时器
                }
            }
            function test(){
                document.querySelector('#text').innerHTML = new Date().getTime();
            }
            document.querySelector('#input').addEventListener('input', debounce(test, 1000))

三十四、开发模式之原生应用、Web应用、混合应用。

	开发原生应用就是适应对应的设备，特别为某种操作系统开发的，如Word只在window上运行，Android系统的专用软件等。
	Web应用：Web应用本质上是为移动浏览器设计的基于Web的应用，它们是用普通Web开发语言开发的，可以在各种智能手机浏览器上运行。简单来说就是使用浏览器访问的网页。
	混合应用大家都知道是原生应用和Web应用的结合体，采用了原生应用的一部分、Web应用的一部分，所以必须在部分在设备上运行、部分在Web上运行。也就是有原生应用的外壳，访问Web服务器。

三十五、有哪些前端优化经验。